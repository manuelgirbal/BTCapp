# Creating map
world <- map_data("world")
nodes_map <- ggplot() +
geom_polygon(data = world, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = nodes_df, aes(x = longitude, y = latitude), color = "orange") +
xlab("Longitude") + ylab("Latitude")
# Clean environment
rm(list = setdiff(ls(), c("yearly", "nodes_df", "nodes_map")))
library(tidyverse)
library(httr)
library(jsonlite)
library(lubridate)
library(plotly)
library(maps)
## Getting price data from  [CoinGecko](https://www.coingecko.com/)
# Define the API endpoint URL
url <- "https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=USD&days=max&interval=daily"
# Send the HTTP request to the API endpoint
response <- GET(url)
# Convert the response to a JSON object
json_data <- fromJSON(content(response, "text"))
# Extract the price data from the JSON object
prices <- json_data$prices
# Convert the price data to a data frame
btcprice <- as_tibble(data.frame(date = as.Date(
as.POSIXct(prices[,1]/1000, origin = "1970-01-01")
),
price = round(prices[,2],1))
)
#Computing yearly variation (of avg price per year):
yearly <- btcprice %>%
mutate(year = year(date)) %>%
group_by(year) %>%
summarise(avg_price = round(mean(price, na.rm = T),2)) %>%
arrange(year) %>%
mutate(year_var = round((avg_price/lag(avg_price)-1),2)) %>%
replace(is.na(.), 0)
## Getting nodes data from  [Bitnodes](https://bitnodes.io/)
# Define the API endpoint URL
url2 <- "https://bitnodes.io/api/v1/snapshots/latest/"
# Send the HTTP request to the API endpoint
response2 <- GET(url2)
# Convert the response to a JSON object
json_data2 <- fromJSON(content(response2, "text"))
# Extract the nodes data from the JSON object
nodes <- json_data2$nodes
node_ids <- names(nodes)
nodes_df <- as_tibble(data.frame(node_ids, do.call(rbind, nodes), stringsAsFactors = FALSE))
colnames(nodes_df) <- c("node_id", "protocol", "user_agent", "connected_since", "services", "height", "hostname", "city", "country_code", "latitude", "longitude", "timezone", "asn", "organization_name")
nodes_df$latitude <- as.numeric(nodes_df$latitude)
nodes_df$longitude <- as.numeric(nodes_df$longitude)
# Creating map
world <- map_data("world")
nodes_map <- ggplot() +
geom_polygon(data = world, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = nodes_df, aes(x = longitude, y = latitude), color = "orange") +
xlab("Longitude") + ylab("Latitude")
# Clean environment
rm(list = setdiff(ls(), c("yearly", "btcprice", "nodes_df", "nodes_map")))
runApp('BTCapp')
# Creating map
world <- map_data("world")
library(tidyverse)
library(httr)
library(jsonlite)
library(lubridate)
library(plotly)
library(maps)
## Getting price data from  [CoinGecko](https://www.coingecko.com/)
# Define the API endpoint URL
url <- "https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=USD&days=max&interval=daily"
# Send the HTTP request to the API endpoint
response <- GET(url)
# Convert the response to a JSON object
json_data <- fromJSON(content(response, "text"))
# Extract the price data from the JSON object
prices <- json_data$prices
# Convert the price data to a data frame
btcprice <- as_tibble(data.frame(date = as.Date(
as.POSIXct(prices[,1]/1000, origin = "1970-01-01")
),
price = round(prices[,2],1))
)
#Computing yearly variation (of avg price per year):
yearly <- btcprice %>%
mutate(year = year(date)) %>%
group_by(year) %>%
summarise(avg_price = round(mean(price, na.rm = T),2)) %>%
arrange(year) %>%
mutate(year_var = round((avg_price/lag(avg_price)-1),2)) %>%
replace(is.na(.), 0)
## Getting nodes data from  [Bitnodes](https://bitnodes.io/)
# Define the API endpoint URL
url2 <- "https://bitnodes.io/api/v1/snapshots/latest/"
# Send the HTTP request to the API endpoint
response2 <- GET(url2)
# Convert the response to a JSON object
json_data2 <- fromJSON(content(response2, "text"))
# Extract the nodes data from the JSON object
nodes <- json_data2$nodes
node_ids <- names(nodes)
nodes_df <- as_tibble(data.frame(node_ids, do.call(rbind, nodes), stringsAsFactors = FALSE))
colnames(nodes_df) <- c("node_id", "protocol", "user_agent", "connected_since", "services", "height", "hostname", "city", "country_code", "latitude", "longitude", "timezone", "asn", "organization_name")
nodes_df$latitude <- as.numeric(nodes_df$latitude)
nodes_df$longitude <- as.numeric(nodes_df$longitude)
# Creating map
world <- map_data("world")
nodes_map <- ggplot() +
geom_polygon(data = world, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = nodes_df, aes(x = longitude, y = latitude), color = "orange") +
xlab("Longitude") + ylab("Latitude")+
theme(plot.background = element_rect(fill = "#A6A6A6"),
panel.background = element_rect(fill = "#A6A6A6"),
panel.grid.major = element_line(colour = "#7A7A7A")
)
# Clean environment
rm(list = setdiff(ls(), c("yearly", "btcprice", "nodes_df", "nodes_map")))
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
rlang::last_trace()
rlang::last_trace(drop = FALSE)
shiny::runApp('BTCapp')
runApp('BTCapp')
View(nodes_map)
nodes_map
ggplot() +
geom_polygon(data = world, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = nodes_df, aes(x = longitude, y = latitude), color = "orange", size = 1) +
xlab("Longitude") + ylab("Latitude") +
theme(plot.background = element_rect(fill = "#A6A6A6"),
panel.background = element_rect(fill = "#A6A6A6"),
panel.grid.major = element_line(colour = "#7A7A7A")
)
# Creating map
world <- map_data("world")
nodes_map <- ggplot() +
geom_polygon(data = world, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = nodes_df, aes(x = longitude, y = latitude), color = "orange", size = 1) +
xlab("Longitude") + ylab("Latitude") +
theme(plot.background = element_rect(fill = "#A6A6A6"),
panel.background = element_rect(fill = "#A6A6A6"),
panel.grid.major = element_line(colour = "#7A7A7A")
)
ggplot() +
geom_polygon(data = world, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = nodes_df, aes(x = longitude, y = latitude), color = "orange", size = 1) +
xlab("Longitude") + ylab("Latitude") +
theme(plot.background = element_rect(fill = "#A6A6A6"),
panel.background = element_rect(fill = "#A6A6A6"),
panel.grid.major = element_line(colour = "#7A7A7A")
)
ggplot() +
geom_polygon(data = world, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = nodes_df, aes(x = longitude, y = latitude), color = "orange", size = 2) +
xlab("Longitude") + ylab("Latitude") +
theme(plot.background = element_rect(fill = "#A6A6A6"),
panel.background = element_rect(fill = "#A6A6A6"),
panel.grid.major = element_line(colour = "#7A7A7A")
)
ggplot() +
geom_polygon(data = world, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = nodes_df, aes(x = longitude, y = latitude), color = "orange", size = 1.5) +
xlab("Longitude") + ylab("Latitude") +
theme(plot.background = element_rect(fill = "#A6A6A6"),
panel.background = element_rect(fill = "#A6A6A6"),
panel.grid.major = element_line(colour = "#7A7A7A")
)
runApp('BTCapp')
View(nodes_df)
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
ggplot() +
geom_polygon(data = world, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = nodes_df, aes(x = longitude, y = latitude), color = "orange", size = 1.5,
text = paste("City:", nodes_df$city, "<br>Latitude:", nodes_df$latitude, "<br>Longitude:", nodes_df$longitude)) +
xlab("Longitude") +
ylab("Latitude") +
theme(plot.background = element_rect(fill = "#A6A6A6"),
panel.background = element_rect(fill = "#A6A6A6"),
panel.grid.major = element_line(colour = "#7A7A7A")
)
# Creating map
world <- map_data("world")
ggplot() +
geom_polygon(data = world, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = nodes_df, aes(x = longitude, y = latitude), color = "orange", size = 1.5,
text = paste("City:", nodes_df$city, "<br>Latitude:", nodes_df$latitude, "<br>Longitude:", nodes_df$longitude)) +
xlab("Longitude") +
ylab("Latitude") +
theme(plot.background = element_rect(fill = "#A6A6A6"),
panel.background = element_rect(fill = "#A6A6A6"),
panel.grid.major = element_line(colour = "#7A7A7A")
)
runApp('BTCapp')
View(nodes_df)
runApp('BTCapp')
runApp('BTCapp')
?value_box
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
shiny::runApp('BTCapp')
runApp('BTCapp')
source(file = bitnodes.R)
source(file = "bitnodes.R")
shiny::runApp('BTCapp')
runApp('BTCapp')
library(tidyverse)
library(httr)
library(jsonlite)
## Getting nodes data from [Bitnodes](https://bitnodes.io/)
# Define the API endpoint URL
url2 <- "https://bitnodes.io/api/v1/snapshots/latest/"
# Send the HTTP request to the API endpoint
response2 <- GET(url2)
# Convert the response to a JSON object
json_data2 <- fromJSON(content(response2, "text"))
# Extract the nodes data from the JSON object
nodes <- json_data2$nodes
node_ids <- names(nodes)
nodes_df <- as_tibble(data.frame(node_ids, do.call(rbind, nodes), stringsAsFactors = FALSE))
colnames(nodes_df) <- c("node_id", "protocol", "user_agent", "connected_since", "services", "height", "hostname", "city", "country_code", "latitude", "longitude", "timezone", "asn", "organization_name")
nodes_df$latitude <- as.numeric(nodes_df$latitude)
nodes_df$longitude <- as.numeric(nodes_df$longitude)
write.csv(nodes_df, file = "nodes.csv")
runApp('BTCapp')
shiny::runApp('BTCapp')
library(tidyverse)
library(httr)
library(jsonlite)
## Getting nodes data from [Bitnodes](https://bitnodes.io/)
# Define the API endpoint URL
url2 <- "https://bitnodes.io/api/v1/snapshots/latest/"
# Send the HTTP request to the API endpoint
response2 <- GET(url2)
# Convert the response to a JSON object
json_data2 <- fromJSON(content(response2, "text"))
# Extract the nodes data from the JSON object
nodes <- json_data2$nodes
node_ids <- names(nodes)
nodes_df <- as_tibble(data.frame(node_ids, do.call(rbind, nodes), stringsAsFactors = FALSE))
colnames(nodes_df) <- c("node_id", "protocol", "user_agent", "connected_since", "services", "height", "hostname", "city", "country_code", "latitude", "longitude", "timezone", "asn", "organization_name")
nodes_df$latitude <- as.numeric(nodes_df$latitude)
nodes_df$longitude <- as.numeric(nodes_df$longitude)
write.csv(nodes_df, file = "BTCapp/nodes.csv")
runApp('BTCapp')
shiny::runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
library(httr)
library(jsonlite)
# URL for the Mempool.space API endpoint
url <- "https://mempool.space/api/txs"
# Send GET request to retrieve Bitcoin transactions
response <- GET(url)
# Check if the request was successful
if (status_code(response) == 200) {
# Extract the response content
content <- content(response, as = "text")
# Parse the JSON response
transactions <- fromJSON(content)
# Print the transactions
print(transactions)
} else {
# Request was not successful, print the error code
print(status_code(response))
}
library(httr)
# Set the API endpoint
endpoint <- "https://mempool.space/api/v1/transactions"
# Make the API request
response <- GET(endpoint)
# Check the response status code
if (response$status_code == 200) {
# Parse the JSON response
transactions <- jsonlite::fromJSON(content(response, "text"))
# Print the transactions
print(transactions)
} else {
# Print the error message
print(response$status_code)
}
library(bitcoincore)
install.packages("bitcoincore")
library(bitcoincore)
library(httr)
# Get the API endpoint URL
url <- "https://api.blockchain.info/charts/total-transaction-count"
# Make the API request
response <- GET(url)
# Check the response status code
if (response$status_code == 200) {
# Parse the JSON response body
data <- jsonlite::fromJSON(content(response, "text"))
# Get the total number of transactions for each year
transactions_per_year <- data$values
# Print the results
print(transactions_per_year)
} else {
# Print an error message
print("Error: API request failed")
}
library(httr)
# Get the API endpoint URL
url <- "https://api.blockchain.info/charts/total-transaction-count"
# Make the API request
response <- GET(url)
# Check the response status code
if (response$status_code == 200) {
# Parse the JSON response body
data <- jsonlite::fromJSON(content(response, "text"))
# Get the total number of transactions for each year
transactions_per_year <- data$values
# Print the results
print(transactions_per_year)
} else {
# Print an error message
print("Error: API request failed")
}
library(httr)
# Get the API endpoint URL
url <- "https://api.blockchain.info/charts/total-transaction-count"
# Make the API request
response <- GET(url)
# Check the response status code
if (response$status_code == 200) {
# Parse the JSON response body
data <- jsonlite::fromJSON(content(response, "text"))
# Get the total number of transactions for each year
transactions_per_year <- data$values
# Print the results
print(transactions_per_year)
} else {
# Print an error message
print("Error: API request failed")
}
library(httr)
# Get the API endpoint URL
url <- "https://api.blockchain.info/charts/total-transaction-count"
# Make the API request
response <- GET(url)
# Check the response status code
if (response$status_code == 200) {
# Parse the JSON response body
data <- jsonlite::fromJSON(content(response, "text"))
# Get the total number of transactions for each year
transactions_per_year <- data$values
# Print the results
print(transactions_per_year)
} else {
# Print an error message
print("Error: API request failed")
}
library(httr)
# Get the API endpoint URL
url <- "https://api.blockchain.info/charts/total-transaction-count"
# Make the API request
response <- GET(url)
# Check the response status code
if (response$status_code == 200) {
# Parse the JSON response body
data <- jsonlite::fromJSON(content(response, "text"))
# Get the total number of transactions for each year
transactions_per_year <- data$values
# Print the results
print(transactions_per_year)
} else {
# Print an error message
print("Error: API request failed")
}
library(httr)
# Get the API endpoint URL
url <- "https://api.blockchain.info/charts/total-transaction-count"
# Make the API request
response <- GET(url)
# Check the response status code
if (response$status_code == 200) {
# Parse the JSON response body
data <- jsonlite::fromJSON(content(response, "text"))
# Get the total number of transactions for each year
transactions_per_year <- data$values
# Print the results
print(transactions_per_year)
} else {
# Print an error message
print("Error: API request failed")
}
library(httr)
# Get the API endpoint URL
url <- "https://api.blockchain.info/charts/total-transaction-count"
# Make the API request
response <- GET(url)
# Check the response status code
if (response$status_code == 200) {
# Parse the JSON response body
data <- jsonlite::fromJSON(content(response, "text"))
# Get the total number of transactions for each year
transactions_per_year <- data$values
# Print the results
print(transactions_per_year)
} else {
# Print an error message
print("Error: API request failed")
}
library(httr)
# Get the API endpoint URL
url <- "https://api.blockchain.info/charts/total-transaction-count"
# Make the API request
response <- GET(url)
# Check the response status code
if (response$status_code == 200) {
# Parse the JSON response body
data <- jsonlite::fromJSON(content(response, "text"))
# Get the total number of transactions for each year
transactions_per_year <- data$values
# Print the results
print(transactions_per_year)
} else {
# Print an error message
print("Error: API request failed")
}
library(httr)
# Get the API endpoint URL
url <- "https://api.blockchain.info/charts/total-transaction-count"
# Make the API request
response <- GET(url)
# Check the response status code
if (response$status_code == 200) {
# Parse the JSON response body
data <- jsonlite::fromJSON(content(response, "text"))
# Get the total number of transactions for each year
transactions_per_year <- data$values
# Print the results
print(transactions_per_year)
} else {
# Print an error message
print("Error: API request failed")
}
shiny::runApp('BTCapp')
nodes_df <- read.csv("R/nodes.csv")
runApp('BTCapp')
nodes_df <- read.csv("nodes.csv")
nodes_df <- read.csv("BTCapp/R/nodes.csv")
runApp('BTCapp')
runApp('BTCapp')
# source(file = "R/bitnodes.R") -- because of "Could not resolve host: bitnodes.io" error in logs, this file has to be run first, manually
source(file = "R/coingecko.R")
library(tidyverse)
library(httr)
library(jsonlite)
library(lubridate)
## Getting price data from [CoinGecko](https://www.coingecko.com/)
# Define the API endpoint URL
url <- "https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=USD&days=max&interval=daily"
# Send the HTTP request to the API endpoint
response <- GET(url)
# Convert the response to a JSON object
json_data <- fromJSON(content(response, "text"))
# Extract the price data from the JSON object
prices <- json_data$prices
# Convert the price data to a data frame
btcprice <- as_tibble(data.frame(date = as.Date(
as.POSIXct(prices[,1]/1000, origin = "1970-01-01")
),
price = round(prices[,2],1))
)
#Computing yearly variation (of avg price per year):
yearly <- btcprice %>%
mutate(year = year(date)) %>%
group_by(year) %>%
summarise(avg_price = round(mean(price, na.rm = T),2)) %>%
arrange(year) %>%
mutate(year_var = round((avg_price/lag(avg_price)-1),2)) %>%
replace(is.na(.), 0)
library(tidyverse)
library(httr)
library(jsonlite)
library(maps)
library(readr)
## Getting nodes data from [Bitnodes](https://bitnodes.io/)
nodes_df <- read.csv("BTCapp/R/nodes.csv")
# Creating map
world <- map_data("world")
nodes_map <- ggplot() +
geom_polygon(data = world, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = nodes_df, aes(x = longitude, y = latitude), color = "orange", size = 1.5) +
xlab("Longitude") +
ylab("Latitude") +
theme(plot.background = element_rect(fill = "#A6A6A6"),
panel.background = element_rect(fill = "#A6A6A6"),
panel.grid.major = element_line(colour = "#7A7A7A")
)
# source(file = "R/bitnodes.R") -- because of "Could not resolve host: bitnodes.io" error in logs, this file has to be run first, manually
source(file = "R/coingecko.R")
source(file = "R/nodes.R")
runApp('BTCapp')
# source(file = "R/bitnodes.R") -- because of "Could not resolve host: bitnodes.io" error in logs, this file has to be run first, manually
source(file = "BTCapp/R/coingecko.R")
source(file = "BTCapp/R/nodes.R")
runApp('BTCapp')
runApp('BTCapp')
shiny::runApp('BTCapp')
