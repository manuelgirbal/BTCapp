rm(list = setdiff(ls(), "btcprice"))
#Computing yearly variation (of avg price per year):
yearly <- btcprice %>%
mutate(year = year(date)) %>%
group_by(year) %>%
summarise(avg_price = round(mean(price, na.rm = T),2)) %>%
arrange(year) %>%
mutate(year_var = round((avg_price/lag(avg_price)-1),2)) %>%
replace(is.na(.), 0)
View(yearly)
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
shiny::runApp('BTCapp')
shiny::runApp('BTCapp')
runApp('BTCapp')
shiny::runApp('BTCapp')
library(tidyverse)
library(httr)
library(jsonlite)
library(lubridate)
library(plotly)
# Define the API endpoint URL
url <- "https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=USD&days=max&interval=daily"
# Send the HTTP request to the API endpoint
response <- GET(url)
# Convert the response to a JSON object
json_data <- fromJSON(content(response, "text"))
# Extract the price data from the JSON object
prices <- json_data$prices
# Convert the price data to a data frame
btcprice <- as_tibble(data.frame(date = as.Date(
as.POSIXct(prices[,1]/1000, origin = "1970-01-01")
),
price = round(prices[,2],1))
)
# Clean environment
rm(list = setdiff(ls(), "btcprice"))
#Computing yearly variation (of avg price per year):
yearly <- btcprice %>%
mutate(year = year(date)) %>%
group_by(year) %>%
summarise(avg_price = round(mean(price, na.rm = T),2)) %>%
arrange(year) %>%
mutate(year_var = round((avg_price/lag(avg_price)-1),2)) %>%
replace(is.na(.), 0)
runApp('BTCapp')
ggplot(btcprice, aes(date, price)) +
geom_line() +
ylab("USD Value") +
xlab("Date") +
scale_x_date(date_breaks = "1 year", date_labels = "%Y")
runApp('BTCapp')
library(tidyverse)
library(httr)
library(jsonlite)
library(lubridate)
library(plotly)
# Define the API endpoint URL
url <- "https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=USD&days=max&interval=daily"
# Send the HTTP request to the API endpoint
response <- GET(url)
# Convert the response to a JSON object
json_data <- fromJSON(content(response, "text"))
# Extract the price data from the JSON object
prices <- json_data$prices
# Convert the price data to a data frame
btcprice <- as_tibble(data.frame(date = as.Date(
as.POSIXct(prices[,1]/1000, origin = "1970-01-01")
),
price = round(prices[,2],1))
)
# Clean environment
rm(list = setdiff(ls(), "btcprice"))
#Computing yearly variation (of avg price per year):
yearly <- btcprice %>%
mutate(year = year(date)) %>%
group_by(year) %>%
summarise(avg_price = round(mean(price, na.rm = T),2)) %>%
arrange(year) %>%
mutate(year_var = round((avg_price/lag(avg_price)-1),2)) %>%
replace(is.na(.), 0)
ggplot(btcprice, aes(date, price)) +
geom_line() +
ylab("USD Value") +
xlab("Date") +
scale_x_date(date_breaks = "1 year", date_labels = "%Y")
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
ggplot(btcprice, aes(date, price)) +
geom_line() +
ylab("USD Value") +
xlab("Date") +
scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
theme_bw() + # optional: use a white background for the plot
theme(bs_theme(bootswatch = "slate")) # set the "slate" theme
install.packages("ggthemes")
library(ggthemes)
ggplot(btcprice, aes(date, price)) +
geom_line() +
ylab("USD Value") +
xlab("Date") +
scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
theme_bw() + # optional: use a white background for the plot
theme(bs_theme(bootswatch = "slate")) # set the "slate" theme
ggplot(btcprice, aes(date, price)) +
geom_line() +
ylab("USD Value") +
xlab("Date") +
scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
theme_slate()
ggplot(btcprice, aes(date, price)) +
geom_line() +
ylab("USD Value") +
xlab("Date") +
scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
theme_minimal() +
theme(panel.grid.major = element_line(color = "#444444"),
panel.grid.minor = element_blank(),
axis.line = element_line(color = "#444444"),
panel.border = element_blank(),
axis.text = element_text(color = "#444444"),
axis.title = element_text(color = "#444444"),
plot.title = element_text(color = "#444444"))
ggplot(btcprice, aes(date, price)) +
geom_line() +
ylab("USD Value") +
xlab("Date") +
scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
theme_minimal()
ggplot(btcprice, aes(date, price)) +
geom_line() +
ylab("USD Value") +
xlab("Date") +
scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
theme_minimal() +
theme(panel.grid.major = element_line(color = "#444444"),
panel.grid.minor = element_blank(),
axis.line = element_line(color = "#444444"),
panel.border = element_blank(),
axis.text = element_text(color = "#444444"),
axis.title = element_text(color = "#444444"),
plot.title = element_text(color = "#444444"),
panel.background = element_rect(fill = "#f7f7f7"))
ggplot(btcprice, aes(date, price)) +
geom_line() +
ylab("USD Value") +
xlab("Date") +
scale_x_date(date_breaks = "1 year", date_labels = "%Y"+
theme_minimal()
ggplot(btcprice, aes(date, price)) +
geom_line() +
ylab("USD Value") +
xlab("Date") +
scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
theme_minimal()
ggplot(btcprice, aes(date, price)) +
geom_line() +
ylab("USD Value") +
xlab("Date") +
scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
theme_minimal()+
theme(panel.background = element_rect(fill = "#E0FFFF"))
ggplot(btcprice, aes(date, price)) +
geom_line() +
ylab("USD Value") +
xlab("Date") +
scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
theme_minimal()+
theme(panel.background = element_rect(fill = "grey"))
ggplot(btcprice, aes(date, price)) +
geom_line() +
ylab("USD Value") +
xlab("Date") +
scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
theme_minimal()+
theme(panel.background = element_rect(fill = "#f7f7f7"))
ggplot(btcprice, aes(date, price)) +
geom_line() +
ylab("USD Value") +
xlab("Date") +
scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
theme_minimal()+
theme(plot.background = element_rect(fill = "#f7f7f7"),
panel.background = element_rect(fill = "#f7f7f7"))
ggplot(btcprice, aes(date, price)) +
geom_line() +
ylab("USD Value") +
xlab("Date") +
scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
theme_minimal()+
theme(plot.background = element_rect(fill = "#DDDDDD"),
panel.background = element_rect(fill = "#A6A6A6"))
ggplot(btcprice, aes(date, price)) +
geom_line() +
ylab("USD Value") +
xlab("Date") +
scale_x_date(date_breaks = "1 year", date_labels = "%Y") +
theme_minimal()+
theme(plot.background = element_rect(fill = "#A6A6A6"),
panel.background = element_rect(fill = "#DDDDDD"))
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
# Define the API endpoint URL
url2 <- "https://bitnodes.io/api/v1/snapshots/latest/"
# Send the HTTP request to the API endpoint
response2 <- GET(url2)
response2
# Convert the response to a JSON object
json_data <- fromJSON(content(response2, "text"))
json_data
View(json_data)
View(response2)
# Convert the response to a JSON object
json_data2 <- fromJSON(content(response2, "text"))
# Extract the price data from the JSON object
nodes <- json_data2$total_nodes
nodes
# Extract the price data from the JSON object
nodes <- json_data2$nodes
class(nodes)
nodes
View(nodes)
runApp('BTCapp')
as.data.frame(nodes)
test <- as.data.frame(nodes)
test
View(test)
# Convert the response to a JSON object
json_data2 <- fromJSON(content(response2, "text"))
# Extract the price data from the JSON object
nodes <- json_data$nodes[[3]]
# Extract the price data from the JSON object
nodes <- json_data2$nodes[[3]]
nodes
json_data2$nodes[3,]
View(json_data2)
# Extract the price data from the JSON object
nodes <- as.data.frame(lapply(json_data2$nodes, function(x) x$value))
# Extract the price data from the JSON object
nodes <- as.data.frame(lapply(json_data2$nodes, function(x) x$Value))
# Extract the price data from the JSON object
nodes <- as.data.frame(json_data2$nodes[c("ip", "city", "country", "latitude", "longitude", "height")])
# Extract the price data from the JSON object
nodes <- as.data.frame(json_data2$nodes[, c("protover", "useragent", "connected_since", "services", "height", "hostname", "city", "country", "latitude", "longitude", "timezone", "asn", "organization_name")])
# Extract the price data from the JSON object
nodes <- as.data.frame(json_data2$nodes[, c("useragent", "services", "height", "hostname", "city", "country", "latitude", "longitude", "timezone", "asn", "organization_name")])
# Extract the price data from the JSON object
nodes <- as.data.frame(json_data2$nodes[c("useragent", "services", "height", "hostname", "city", "country", "latitude", "longitude", "timezone", "asn", "organization_name")])
View(nodes)
# Define the API endpoint URL
url2 <- "https://bitnodes.io/api/v1/snapshots/latest/"
# Send the HTTP request to the API endpoint
response2 <- GET(url2)
# Convert the response to a JSON object
json_data2 <- fromJSON(content(response2, "text"))
# Extract the nodes data from the JSON object
nodes <- json_data2$nodes
# Extract the nodes data from the JSON object
nodes <- json_data2$nodes
nodes_df <- as.data.frame(nodes, stringsAsFactors = FALSE)
View(nodes_df)
# Extract the nodes data from the JSON object
nodes <- json_data2$nodes
node_ids <- names(nodes)
node_ids
node_info <- lapply(nodes, function(x) unlist(x))
node_info
View(nodes)
View(node_info)
nodes_df <- data.frame(node_id = node_ids, do.call(rbind, node_info), stringsAsFactors = FALSE)
View(nodes_df)
node_info[[1]]
View(nodes)
View(json_data2)
?do.call
colnames(nodes_df) <- c("node_id", "protocol", "user_agent", "connected_since", "services", "height", "hostname", "city", "country_code", "latitude", "longitude", "timezone", "asn", "organization_name")
View(nodes_df)
nodes_df
nodes_df <- data.frame(node_ids, do.call(rbind, nodes), stringsAsFactors = FALSE)
colnames(nodes_df) <- c("node_id", "protocol", "user_agent", "connected_since", "services", "height", "hostname", "city", "country_code", "latitude", "longitude", "timezone", "asn", "organization_name")
View(nodes_df)
# Extract the nodes data from the JSON object
nodes <- json_data2$nodes
node_ids <- names(nodes)
nodes_df <- as_tibble(data.frame(node_ids, do.call(rbind, nodes), stringsAsFactors = FALSE))
colnames(nodes_df) <- c("node_id", "protocol", "user_agent", "connected_since", "services", "height", "hostname", "city", "country_code", "latitude", "longitude", "timezone", "asn", "organization_name")
nodes_df
View(nodes_df)
# Clean environment
rm(list = setdiff(ls(), c("btcprice", "nodes_df")))
View(nodes_df)
?geom_sf
library(maps)
library(maps)
# create a map of the world
world <- map_data("world")
ggplot() +
geom_polygon(data = world, aes(x = long, y = lat, group = group), fill = "white", color = "black")
ggplot() +
geom_polygon(data = world, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = nodes_df, aes(x = longitude, y = latitude), color = "red") +
xlab("Longitude") + ylab("Latitude") +
ggtitle("Bitcoin Nodes on World Map")
nodes_df
nodes_df$latitude <- as.numeric(nodes_df$latitude)
nodes_df$longitude <- as.numeric(nodes_df$longitude)
ggplot() +
geom_polygon(data = world, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = nodes_df, aes(x = longitude, y = latitude), color = "red") +
xlab("Longitude") + ylab("Latitude") +
ggtitle("Bitcoin Nodes on World Map")
# Clean environment
rm(list = setdiff(ls(), c("btcprice", "nodes_df", "nodes_map")))
# Creating map
world <- map_data("world")
nodes_map %>% ggplot() +
geom_polygon(data = world, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = nodes_df, aes(x = longitude, y = latitude), color = "red") +
xlab("Longitude") + ylab("Latitude")
ggplot() +
geom_polygon(data = world, aes(x = long, y = lat, group = group)) +
geom_point(data = nodes_df, aes(x = longitude, y = latitude), color = "red") +
xlab("Longitude") + ylab("Latitude")
nodes_map <- ggplot() +
geom_polygon(data = world, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = nodes_df, aes(x = longitude, y = latitude), color = "orange") +
xlab("Longitude") + ylab("Latitude")
# Clean environment
rm(list = setdiff(ls(), c("btcprice", "nodes_df", "nodes_map")))
nodes_map
runApp('BTCapp')
library(tidyverse)
library(httr)
library(jsonlite)
library(lubridate)
library(plotly)
library(maps)
## Getting price data from  [CoinGecko](https://www.coingecko.com/)
# Define the API endpoint URL
url <- "https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=USD&days=max&interval=daily"
# Send the HTTP request to the API endpoint
response <- GET(url)
# Convert the response to a JSON object
json_data <- fromJSON(content(response, "text"))
# Extract the price data from the JSON object
prices <- json_data$prices
# Convert the price data to a data frame
btcprice <- as_tibble(data.frame(date = as.Date(
as.POSIXct(prices[,1]/1000, origin = "1970-01-01")
),
price = round(prices[,2],1))
)
#Computing yearly variation (of avg price per year):
yearly <- btcprice %>%
mutate(year = year(date)) %>%
group_by(year) %>%
summarise(avg_price = round(mean(price, na.rm = T),2)) %>%
arrange(year) %>%
mutate(year_var = round((avg_price/lag(avg_price)-1),2)) %>%
replace(is.na(.), 0)
## Getting nodes data from  [Bitnodes](https://bitnodes.io/)
# Define the API endpoint URL
url2 <- "https://bitnodes.io/api/v1/snapshots/latest/"
# Send the HTTP request to the API endpoint
response2 <- GET(url2)
# Convert the response to a JSON object
json_data2 <- fromJSON(content(response2, "text"))
# Extract the nodes data from the JSON object
nodes <- json_data2$nodes
node_ids <- names(nodes)
nodes_df <- as_tibble(data.frame(node_ids, do.call(rbind, nodes), stringsAsFactors = FALSE))
colnames(nodes_df) <- c("node_id", "protocol", "user_agent", "connected_since", "services", "height", "hostname", "city", "country_code", "latitude", "longitude", "timezone", "asn", "organization_name")
nodes_df$latitude <- as.numeric(nodes_df$latitude)
nodes_df$longitude <- as.numeric(nodes_df$longitude)
# Creating map
world <- map_data("world")
nodes_map <- ggplot() +
geom_polygon(data = world, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = nodes_df, aes(x = longitude, y = latitude), color = "orange") +
xlab("Longitude") + ylab("Latitude")
# Clean environment
rm(list = setdiff(ls(), c("yearly", "nodes_df", "nodes_map")))
library(tidyverse)
library(httr)
library(jsonlite)
library(lubridate)
library(plotly)
library(maps)
## Getting price data from  [CoinGecko](https://www.coingecko.com/)
# Define the API endpoint URL
url <- "https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=USD&days=max&interval=daily"
# Send the HTTP request to the API endpoint
response <- GET(url)
# Convert the response to a JSON object
json_data <- fromJSON(content(response, "text"))
# Extract the price data from the JSON object
prices <- json_data$prices
# Convert the price data to a data frame
btcprice <- as_tibble(data.frame(date = as.Date(
as.POSIXct(prices[,1]/1000, origin = "1970-01-01")
),
price = round(prices[,2],1))
)
#Computing yearly variation (of avg price per year):
yearly <- btcprice %>%
mutate(year = year(date)) %>%
group_by(year) %>%
summarise(avg_price = round(mean(price, na.rm = T),2)) %>%
arrange(year) %>%
mutate(year_var = round((avg_price/lag(avg_price)-1),2)) %>%
replace(is.na(.), 0)
## Getting nodes data from  [Bitnodes](https://bitnodes.io/)
# Define the API endpoint URL
url2 <- "https://bitnodes.io/api/v1/snapshots/latest/"
# Send the HTTP request to the API endpoint
response2 <- GET(url2)
# Convert the response to a JSON object
json_data2 <- fromJSON(content(response2, "text"))
# Extract the nodes data from the JSON object
nodes <- json_data2$nodes
node_ids <- names(nodes)
nodes_df <- as_tibble(data.frame(node_ids, do.call(rbind, nodes), stringsAsFactors = FALSE))
colnames(nodes_df) <- c("node_id", "protocol", "user_agent", "connected_since", "services", "height", "hostname", "city", "country_code", "latitude", "longitude", "timezone", "asn", "organization_name")
nodes_df$latitude <- as.numeric(nodes_df$latitude)
nodes_df$longitude <- as.numeric(nodes_df$longitude)
# Creating map
world <- map_data("world")
nodes_map <- ggplot() +
geom_polygon(data = world, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = nodes_df, aes(x = longitude, y = latitude), color = "orange") +
xlab("Longitude") + ylab("Latitude")
# Clean environment
rm(list = setdiff(ls(), c("yearly", "btcprice", "nodes_df", "nodes_map")))
runApp('BTCapp')
# Creating map
world <- map_data("world")
library(tidyverse)
library(httr)
library(jsonlite)
library(lubridate)
library(plotly)
library(maps)
## Getting price data from  [CoinGecko](https://www.coingecko.com/)
# Define the API endpoint URL
url <- "https://api.coingecko.com/api/v3/coins/bitcoin/market_chart?vs_currency=USD&days=max&interval=daily"
# Send the HTTP request to the API endpoint
response <- GET(url)
# Convert the response to a JSON object
json_data <- fromJSON(content(response, "text"))
# Extract the price data from the JSON object
prices <- json_data$prices
# Convert the price data to a data frame
btcprice <- as_tibble(data.frame(date = as.Date(
as.POSIXct(prices[,1]/1000, origin = "1970-01-01")
),
price = round(prices[,2],1))
)
#Computing yearly variation (of avg price per year):
yearly <- btcprice %>%
mutate(year = year(date)) %>%
group_by(year) %>%
summarise(avg_price = round(mean(price, na.rm = T),2)) %>%
arrange(year) %>%
mutate(year_var = round((avg_price/lag(avg_price)-1),2)) %>%
replace(is.na(.), 0)
## Getting nodes data from  [Bitnodes](https://bitnodes.io/)
# Define the API endpoint URL
url2 <- "https://bitnodes.io/api/v1/snapshots/latest/"
# Send the HTTP request to the API endpoint
response2 <- GET(url2)
# Convert the response to a JSON object
json_data2 <- fromJSON(content(response2, "text"))
# Extract the nodes data from the JSON object
nodes <- json_data2$nodes
node_ids <- names(nodes)
nodes_df <- as_tibble(data.frame(node_ids, do.call(rbind, nodes), stringsAsFactors = FALSE))
colnames(nodes_df) <- c("node_id", "protocol", "user_agent", "connected_since", "services", "height", "hostname", "city", "country_code", "latitude", "longitude", "timezone", "asn", "organization_name")
nodes_df$latitude <- as.numeric(nodes_df$latitude)
nodes_df$longitude <- as.numeric(nodes_df$longitude)
# Creating map
world <- map_data("world")
nodes_map <- ggplot() +
geom_polygon(data = world, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = nodes_df, aes(x = longitude, y = latitude), color = "orange") +
xlab("Longitude") + ylab("Latitude")+
theme(plot.background = element_rect(fill = "#A6A6A6"),
panel.background = element_rect(fill = "#A6A6A6"),
panel.grid.major = element_line(colour = "#7A7A7A")
)
# Clean environment
rm(list = setdiff(ls(), c("yearly", "btcprice", "nodes_df", "nodes_map")))
runApp('BTCapp')
runApp('BTCapp')
runApp('BTCapp')
rlang::last_trace()
rlang::last_trace(drop = FALSE)
